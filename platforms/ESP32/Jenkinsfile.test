pipeline {
    agent none

    parameters {
        string(
            name: 'BUILD_JOB_NAME',
            defaultValue: 'platforms/ESP32/ats-fw-esp32-demo',
            description: 'Name of the build job that produced the firmware (with folder path)'
        )
        string(
            name: 'BUILD_NUMBER',
            defaultValue: '',
            description: 'Build number of the firmware to test'
        )
        string(
            name: 'ATS_NODE_LABEL',
            defaultValue: 'raspi-ats-01',
            description: 'Label for ATS node pool (e.g., ats-node, ats-pi-01)'
        )
        choice(
            name: 'IMAGE_SOURCE',
            choices: ['registry', 'build'],
            description: 'How to get ats-node-test image: pull from registry or build on agent'
        )
        string(
            name: 'ATS_NODE_TEST_IMAGE',
            defaultValue: 'ghcr.io/picopiece/ats-node-test:latest',
            description: 'Docker image name for ATS node test container (registry or local)'
        )
        string(
            name: 'TEST_REPO_URL',
            defaultValue: 'https://github.com/PicoPiece/ats-test-esp32-demo.git',
            description: 'Git URL of the test framework repository'
        )
        string(
            name: 'TEST_REPO_BRANCH',
            defaultValue: 'main',
            description: 'Branch of the test framework repository to use'
        )
    }

    environment {
        WORKSPACE_DIR = "workspace"
        RESULTS_DIR = "results"
        TEST_REPO_DIR = "ats-test-esp32-demo"
    }

    stages {
        stage('Prepare Workspace') {
            agent { label "${params.ATS_NODE_LABEL}" }
            steps {
                script {
                    if (!params.BUILD_NUMBER || params.BUILD_NUMBER == '') {
                        error("BUILD_NUMBER parameter is required")
                    }
                    
                    // Create workspace directory
                    sh """
                        mkdir -p ${WORKSPACE_DIR}
                        cd ${WORKSPACE_DIR}
                    """
                    
                    // Copy firmware artifacts from build job
                    echo "üì• Copying firmware artifacts from ${params.BUILD_JOB_NAME} #${params.BUILD_NUMBER}"
                    
                    // Copy artifacts in two steps to ensure both are copied
                    copyArtifacts(
                        projectName: params.BUILD_JOB_NAME,
                        selector: [
                            $class: 'SpecificBuildSelector',
                            buildNumber: params.BUILD_NUMBER.toString()
                        ],
                        filter: "*.bin",
                        target: WORKSPACE_DIR,
                        flatten: true
                    )
                    
                    copyArtifacts(
                        projectName: params.BUILD_JOB_NAME,
                        selector: [
                            $class: 'SpecificBuildSelector',
                            buildNumber: params.BUILD_NUMBER.toString()
                        ],
                        filter: "ats-manifest.yaml",
                        target: WORKSPACE_DIR,
                        flatten: true
                    )
                    
                    // Verify artifacts were copied
                    sh """
                        echo "üì¶ Verifying copied artifacts..."
                        echo "   Workspace directory: ${WORKSPACE_DIR}"
                        echo "   Current directory: \$(pwd)"
                        echo ""
                        echo "   All files in workspace:"
                        ls -lah ${WORKSPACE_DIR}/ || true
                        echo ""
                        echo "   Firmware binaries:"
                        ls -lh ${WORKSPACE_DIR}/*.bin 2>/dev/null || echo "   ‚ö†Ô∏è  No .bin files found"
                        echo ""
                        echo "   Manifest file:"
                        if [ -f ${WORKSPACE_DIR}/ats-manifest.yaml ]; then
                            echo "   ‚úÖ ats-manifest.yaml found"
                            ls -lh ${WORKSPACE_DIR}/ats-manifest.yaml
                        else
                            echo "   ‚ùå ats-manifest.yaml NOT found"
                            echo "   This will cause the test stage to fail!"
                        fi
                        echo ""
                    """
                    
                    // Checkout test framework
                    echo "üì¶ Checking out test framework: ${params.TEST_REPO_URL}"
                    dir(WORKSPACE_DIR) {
                        checkout([
                            $class: 'GitSCM',
                            branches: [[name: "*/${params.TEST_REPO_BRANCH}"]],
                            doGenerateSubmoduleConfigurations: false,
                            extensions: [[
                                $class: 'RelativeTargetDirectory',
                                relativeTargetDir: TEST_REPO_DIR
                            ]],
                            submoduleCfg: [],
                            userRemoteConfigs: [[
                                url: params.TEST_REPO_URL,
                                credentialsId: ''
                            ]]
                        ])
                    }
                    
                    // Verify workspace structure and fail if manifest is missing
                    sh """
                        echo "‚úÖ Final workspace verification:"
                        echo "   Workspace: ${WORKSPACE_DIR}"
                        ls -lah ${WORKSPACE_DIR}/ || true
                        echo ""
                        echo "üìã Manifest verification:"
                        if [ -f ${WORKSPACE_DIR}/ats-manifest.yaml ]; then
                            echo "‚úÖ Manifest found:"
                            cat ${WORKSPACE_DIR}/ats-manifest.yaml
                            echo ""
                            echo "‚úÖ Workspace preparation completed successfully"
                        else
                            echo "‚ùå ERROR: Manifest NOT found in ${WORKSPACE_DIR}/"
                            echo ""
                            echo "   Troubleshooting:"
                            echo "   1. Check if build job '${params.BUILD_JOB_NAME}' #${params.BUILD_NUMBER} exists"
                            echo "   2. Verify build job archived 'ats-manifest.yaml'"
                            echo "   3. Check Jenkins console for copyArtifacts errors"
                            echo "   4. Verify BUILD_NUMBER parameter is correct"
                            echo ""
                            echo "   Current workspace contents:"
                            ls -la ${WORKSPACE_DIR}/ || true
                            echo ""
                            exit 1
                        fi
                    """
                }
            }
        }

        stage('Prepare ATS Node Test Container') {
            agent { label "${params.ATS_NODE_LABEL}" }
            steps {
                script {
                    if (params.IMAGE_SOURCE == 'registry') {
                        // Option 1: Pull from registry (fast, recommended)
                        echo "üì• Pulling ATS node test image from registry..."
                        echo "   Image: ${params.ATS_NODE_TEST_IMAGE}"
                        
                        sh """
                            echo "   Platform: \$(uname -m)"
                            echo "   Architecture: \$(uname -a)"
                        """
                        
                        // Use the full image name from parameter (should include registry)
                        def imageToPull = params.ATS_NODE_TEST_IMAGE
                        if (!imageToPull.contains('/') && !imageToPull.contains('.')) {
                            // If no registry prefix, assume it's just the name and add default
                            imageToPull = "ghcr.io/picopiece/${imageToPull}"
                            echo "   ‚ö†Ô∏è  Warning: Image name missing registry prefix, using: ${imageToPull}"
                        }
                        
                        // Try to login to GHCR if credentials are available (optional)
                        def ghcrCredsId = params.GHCR_CREDENTIALS_ID ?: env.GHCR_CREDENTIALS_ID ?: ''
                        def pullSuccess = false
                        
                        if (ghcrCredsId && ghcrCredsId != '') {
                            echo "üîê Attempting to login to GHCR with credentials ID: ${ghcrCredsId}"
                            try {
                                withCredentials([usernamePassword(credentialsId: ghcrCredsId,
                                                 usernameVariable: 'GHCR_USER',
                                                 passwordVariable: 'GHCR_TOKEN')]) {
                                    sh """
                                        echo "Logging into GHCR..."
                                        echo "\$GHCR_TOKEN" | docker login ghcr.io -u "\$GHCR_USER" --password-stdin
                                        echo "‚úÖ GHCR login successful"
                                        
                                        echo "üì• Pulling image: ${imageToPull}"
                                        docker pull ${imageToPull}
                                        
                                        # Tag with the expected name for consistency
                                        docker tag ${imageToPull} ${params.ATS_NODE_TEST_IMAGE} || true
                                    """
                                }
                                pullSuccess = true
                                echo "‚úÖ Image pulled successfully: ${imageToPull}"
                            } catch (Exception e) {
                                echo "‚ö†Ô∏è  Failed to use credentials ${ghcrCredsId}: ${e.getMessage()}"
                                echo "   Will try pull without login (works if image is public)"
                                
                                // Fallback: try pull without credentials
                                pullSuccess = sh(
                                    script: "docker pull ${imageToPull} 2>&1",
                                    returnStatus: true
                                ) == 0
                                
                                if (pullSuccess) {
                                    echo "‚úÖ Image pulled successfully (public): ${imageToPull}"
                                    sh "docker tag ${imageToPull} ${params.ATS_NODE_TEST_IMAGE} || true"
                                }
                            }
                        } else {
                            echo "‚ÑπÔ∏è  No GHCR credentials provided, trying public pull..."
                            pullSuccess = sh(
                                script: "docker pull ${imageToPull} 2>&1",
                                returnStatus: true
                            ) == 0
                            
                            if (pullSuccess) {
                                echo "‚úÖ Image pulled successfully: ${imageToPull}"
                                // Tag with the expected name for consistency
                                sh "docker tag ${imageToPull} ${params.ATS_NODE_TEST_IMAGE} || true"
                            }
                        }
                        
                        if (!pullSuccess) {
                            echo "‚ö†Ô∏è  Failed to pull image from registry"
                            echo ""
                            sh """
                                echo "   Error details:"
                                docker pull ${params.ATS_NODE_TEST_IMAGE} 2>&1 | head -5 || true
                                echo ""
                                echo "   Common reasons:"
                                echo "   1. Image is private and requires authentication"
                                echo "      ‚Üí Setup GHCR_CREDENTIALS_ID in Jenkins or make image public"
                                echo "   2. Image doesn't exist for this platform (\$(uname -m))"
                                echo "      ‚Üí Check registry for available platforms"
                                echo "   3. Network/registry connectivity issue"
                                echo "      ‚Üí Check network/firewall settings"
                                echo ""
                                echo "   Note: Falling back to local build (this may take longer)"
                                echo ""
                            """
                            echo "   Falling back to build on agent..."
                            // Fall back to build with hotfix
                            dir(WORKSPACE_DIR) {
                                sh """
                                    set -euo pipefail
                                    echo "üîç Current directory: \$(pwd)"
                                    # Compute absolute workspace path
                                    WORKSPACE_ABS=\$(pwd)
                                    echo "üîç WORKSPACE_ABS: \$WORKSPACE_ABS"
                                    echo ""
                                    
                                    # Ensure ats-ats-node repo exists under WORKSPACE_ABS
                                    if [ ! -d "\${WORKSPACE_ABS}/ats-ats-node" ]; then
                                        echo "üì¶ Cloning ats-ats-node into \${WORKSPACE_ABS}/ats-ats-node..."
                                        git clone https://github.com/PicoPiece/ats-ats-node.git ats-ats-node || {
                                            echo "‚ùå Failed to clone ats-ats-node"
                                            exit 1
                                        }
                                    else
                                        echo "üì¶ ats-ats-node already exists, pulling latest..."
                                        cd \${WORKSPACE_ABS}/ats-ats-node
                                        git pull origin main || echo "‚ö†Ô∏è  git pull failed, using existing code"
                                    fi
                                    
                                    # Verify directory and Dockerfile
                                    if [ -d "\${WORKSPACE_ABS}/ats-ats-node/docker/ats-node-test" ] && [ -f "\${WORKSPACE_ABS}/ats-ats-node/docker/ats-node-test/Dockerfile" ]; then
                                        echo "üê≥ Build context ready: \${WORKSPACE_ABS}/ats-ats-node/docker/ats-node-test"
                                        cd \${WORKSPACE_ABS}/ats-ats-node/docker/ats-node-test
                                        
                                        # Check if buildx is available, if not disable BuildKit
                                        if docker buildx version > /dev/null 2>&1; then
                                            export DOCKER_BUILDKIT=1
                                            echo "üß∞ Building ATS node test image with BuildKit..."
                                        else
                                            echo "‚ö†Ô∏è  BuildKit/buildx not available, using legacy builder..."
                                            unset DOCKER_BUILDKIT || true
                                        fi
                                        docker build --pull -t ${params.ATS_NODE_TEST_IMAGE} .
                                        echo "‚úÖ Container built: ${params.ATS_NODE_TEST_IMAGE}"
                                    else
                                        echo "‚ùå ERROR: Dockerfile not found at expected location: \${WORKSPACE_ABS}/ats-ats-node/docker/ats-node-test/Dockerfile"
                                        echo "Repository layout:"
                                        ls -lah \${WORKSPACE_ABS}/ats-ats-node || true
                                        exit 1
                                    fi
                                """
                            }
                        }
                    } else {
                        // Option 2: Build on agent (slow, but works without registry)
                        echo "üî® Building ATS node test container on agent..."
                        dir(WORKSPACE_DIR) {
                            sh """
                                set -euo pipefail
                                echo "üîç Current directory: \$(pwd)"
                                # Compute absolute workspace path
                                WORKSPACE_ABS=\$(pwd)
                                echo "üîç WORKSPACE_ABS: \$WORKSPACE_ABS"
                                echo ""
                                
                                # Ensure ats-ats-node repo exists under WORKSPACE_ABS
                                if [ ! -d "\${WORKSPACE_ABS}/ats-ats-node" ]; then
                                    echo "üì¶ Cloning ats-ats-node into \${WORKSPACE_ABS}/ats-ats-node..."
                                    git clone https://github.com/PicoPiece/ats-ats-node.git ats-ats-node || {
                                        echo "‚ùå Failed to clone ats-ats-node"
                                        exit 1
                                    }
                                else
                                    echo "üì¶ ats-ats-node already exists, pulling latest..."
                                    cd \${WORKSPACE_ABS}/ats-ats-node
                                    git pull origin main || echo "‚ö†Ô∏è  git pull failed, using existing code"
                                fi
                                
                                # Verify directory and Dockerfile
                                if [ -d "\${WORKSPACE_ABS}/ats-ats-node/docker/ats-node-test" ] && [ -f "\${WORKSPACE_ABS}/ats-ats-node/docker/ats-node-test/Dockerfile" ]; then
                                    echo "üê≥ Build context ready: \${WORKSPACE_ABS}/ats-ats-node/docker/ats-node-test"
                                    cd \${WORKSPACE_ABS}/ats-ats-node/docker/ats-node-test
                                    
                                    # Check if buildx is available, if not disable BuildKit
                                    if docker buildx version > /dev/null 2>&1; then
                                        export DOCKER_BUILDKIT=1
                                        echo "üß∞ Building ATS node test image with BuildKit..."
                                    else
                                        echo "‚ö†Ô∏è  BuildKit/buildx not available, using legacy builder..."
                                        unset DOCKER_BUILDKIT || true
                                    fi
                                    docker build --pull -t ${params.ATS_NODE_TEST_IMAGE} .
                                    echo "‚úÖ Container built: ${params.ATS_NODE_TEST_IMAGE}"
                                else
                                    echo "‚ùå ERROR: Dockerfile not found at expected location: \${WORKSPACE_ABS}/ats-ats-node/docker/ats-node-test/Dockerfile"
                                    echo "Repository layout:"
                                    ls -lah \${WORKSPACE_ABS}/ats-ats-node || true
                                    exit 1
                                fi
                            """
                        }
                    }
                }
            }
        }

        stage('Run ATS Tests') {
            agent { label "${params.ATS_NODE_LABEL}" }
            steps {
                dir(WORKSPACE_DIR) {
                    sh """
                        echo "üöÄ [ATS] Running test execution container"
                        echo "üìã Image: ${params.ATS_NODE_TEST_IMAGE}"
                        echo "üìÅ Workspace: \$(pwd)"
                        
                        # Verify workspace contents before running container
                        echo "üì¶ Workspace contents:"
                        ls -lah \$(pwd)/
                        echo ""
                        
                        # Verify manifest exists
                        if [ ! -f ats-manifest.yaml ]; then
                            echo "‚ùå ERROR: ats-manifest.yaml not found in workspace!"
                            echo "   Expected path: \$(pwd)/ats-manifest.yaml"
                            echo "   Current directory: \$(pwd)"
                            echo "   Files in workspace:"
                            ls -lah \$(pwd)/ || true
                            echo ""
                            echo "   This usually means:"
                            echo "   1. Build job did not archive ats-manifest.yaml"
                            echo "   2. copyArtifacts failed in Prepare Workspace stage"
                            echo "   3. Wrong BUILD_NUMBER parameter"
                            exit 1
                        fi
                        
                        echo "‚úÖ Manifest found: \$(pwd)/ats-manifest.yaml"
                        echo "üìã Manifest content:"
                        cat ats-manifest.yaml
                        echo ""
                        
                        # Verify firmware binary exists
                        FW_BIN=\$(ls *.bin 2>/dev/null | head -1)
                        if [ -z "\$FW_BIN" ]; then
                            echo "‚ö†Ô∏è  Warning: No .bin firmware file found in workspace"
                        else
                            echo "‚úÖ Firmware binary found: \$FW_BIN"
                        fi
                        echo ""
                        
                        # Create results directory
                        mkdir -p ${RESULTS_DIR}
                        
                        # Ensure manifest and directory are readable by container
                        chmod 644 ats-manifest.yaml || true
                        chmod 755 . || true  # Ensure directory is traversable
                        chown \$(id -u):\$(id -g) ats-manifest.yaml 2>/dev/null || true
                        echo "üîç File permissions on host:"
                        ls -lah ats-manifest.yaml
                        echo "üîç Directory permissions:"
                        ls -ld .
                        echo ""
                        
                        # CRITICAL: Jenkins agent runs in a container, and we're running Docker inside that container
                        # This is a "Docker-in-Docker" scenario where we need to mount from the HOST filesystem
                        # 
                        # Agent container setup (from start-agent.sh):
                        #   -v /home/jenkins:/home/jenkins/agent (host -> container)
                        #   -v /var/run/docker.sock:/var/run/docker.sock
                        #
                        # So if we're at /home/jenkins/workspace/... in agent container,
                        # the HOST path is also /home/jenkins/workspace/... (same path on host)
                        #
                        # However, Docker inside container needs to mount from HOST, not container filesystem
                        # Solution: Use the path as-is since agent container mounts host /home/jenkins directly
                        
                        WORKSPACE_ABS=\$(pwd)
                        echo "üîç Current directory (in agent container): \${WORKSPACE_ABS}"
                        
                        # Verify we can see files from agent container perspective
                        echo "üîç Files visible from agent container:"
                        ls -lah \${WORKSPACE_ABS}/ | head -10
                        echo ""
                        
                        # Since agent container mounts /home/jenkins from host, the path should work
                        # But we need to ensure Docker can access it. Try to find the actual host mount point
                        # Check if we're in a container by looking at /.dockerenv or /proc/1/cgroup
                        if [ -f /.dockerenv ] || grep -qa docker /proc/1/cgroup 2>/dev/null; then
                            echo "üîç Running inside container (Jenkins agent)"
                            echo "   Agent container should have mounted host /home/jenkins"
                            echo "   Using path as-is for Docker mount: \${WORKSPACE_ABS}"
                        else
                            echo "üîç Running directly on host"
                            echo "   Using path as-is: \${WORKSPACE_ABS}"
                        fi
                        
                        # CRITICAL FIX: Test mount with actual file check, not just directory listing
                        echo "üîç Testing volume mount with actual file access..."
                        MOUNT_TEST=\$(docker run --rm -v "\${WORKSPACE_ABS}:/workspace" alpine:latest sh -c "test -f /workspace/ats-manifest.yaml && echo 'FILE_EXISTS' || echo 'FILE_MISSING'" 2>&1)
                        
                        if echo "\$MOUNT_TEST" | grep -q "FILE_EXISTS"; then
                            echo "‚úÖ Mount test PASSED - manifest file is accessible in container"
                            echo "   File content preview:"
                            docker run --rm -v "\${WORKSPACE_ABS}:/workspace" alpine:latest head -5 /workspace/ats-manifest.yaml 2>&1 || true
                        else
                            echo "‚ùå CRITICAL: Mount test FAILED - file not accessible!"
                            echo "   Test output: \$MOUNT_TEST"
                            echo ""
                            echo "   This means Docker cannot access files from this path."
                            echo "   Possible causes:"
                            echo "   1. Path is inside container filesystem, not host filesystem"
                            echo "   2. Docker socket doesn't have access to this path"
                            echo "   3. Permission issues"
                            echo ""
                            echo "   Attempting alternative: Copy files to temp location on host..."
                            
                            # Alternative: Copy to a known host location that Docker can access
                            # Use /tmp which should be accessible from host
                            HOST_TMP="/tmp/jenkins-workspace-\$(date +%s)"
                            mkdir -p "\${HOST_TMP}"
                            echo "   Copying workspace to: \${HOST_TMP}"
                            
                            # Copy files with proper handling
                            cd \${WORKSPACE_ABS}
                            cp -r . "\${HOST_TMP}/" || {
                                echo "   ‚ùå Failed to copy files"
                                exit 1
                            }
                            
                            # Verify files were copied
                            echo "   Verifying copied files:"
                            ls -lah "\${HOST_TMP}/" | head -10
                            
                            # Test mount with copied files
                            echo "   Testing mount with copied files..."
                            COPY_TEST=\$(docker run --rm -v "\${HOST_TMP}:/workspace" alpine:latest sh -c "test -f /workspace/ats-manifest.yaml && echo 'FILE_EXISTS' || echo 'FILE_MISSING'" 2>&1)
                            
                            if echo "\$COPY_TEST" | grep -q "FILE_EXISTS"; then
                                echo "   ‚úÖ Copy successful - files accessible in container"
                                WORKSPACE_ABS="\${HOST_TMP}"
                                echo "   ‚úÖ Using alternative path: \${WORKSPACE_ABS}"
                                echo "   ‚ö†Ô∏è  Note: Results will need to be copied back"
                            else
                                echo "   ‚ùå Copy failed - files still not accessible"
                                echo "   Test output: \$COPY_TEST"
                                echo "   This indicates a deeper Docker-in-Docker issue"
                                exit 1
                            fi
                        fi
                        echo ""
                        
                        # Run test container with workspace mount
                        # Mount workspace FIRST, then hardware devices
                        echo "üöÄ Running ATS test container..."
                        echo "   Workspace mount: \${WORKSPACE_ABS} -> /workspace"
                        
                        docker run --rm --privileged \\
                            -v "\${WORKSPACE_ABS}:/workspace" \\
                            -v /dev:/dev \\
                            -v /sys/class/gpio:/sys/class/gpio:ro \\
                            -v /dev/gpiomem:/dev/gpiomem \\
                            -e MANIFEST_PATH=/workspace/ats-manifest.yaml \\
                            -e RESULTS_DIR=/workspace/${RESULTS_DIR} \\
                            ${params.ATS_NODE_TEST_IMAGE}
                        
                        EXIT_CODE=\$?
                        
                        # If we used alternative path, copy results back
                        if [ "\${WORKSPACE_ABS}" != "\$(pwd)" ] && [ -d "\${WORKSPACE_ABS}/${RESULTS_DIR}" ]; then
                            echo "üì¶ Copying results back from alternative path..."
                            cp -r "\${WORKSPACE_ABS}/${RESULTS_DIR}"/* "\$(pwd)/${RESULTS_DIR}/" 2>/dev/null || true
                            rm -rf "\${WORKSPACE_ABS}" 2>/dev/null || true
                        fi
                        
                        if [ \$EXIT_CODE -eq 0 ]; then
                            echo "‚úÖ Test execution completed successfully"
                        else
                            echo "‚ùå Test execution failed with exit code: \$EXIT_CODE"
                        fi
                        
                        echo "üìä Results:"
                        ls -la ${RESULTS_DIR}/ || echo "   No results found"
                    """
                }
            }
        }

        stage('Archive Results') {
            agent { label "${params.ATS_NODE_LABEL}" }
            steps {
                dir(WORKSPACE_DIR) {
                    archiveArtifacts artifacts: "${RESULTS_DIR}/**", allowEmptyArchive: true
                    publishTestResults testResultsPattern: "${RESULTS_DIR}/**/*.xml", allowEmptyResults: true
                }
            }
        }
    }

    post {
        success {
            echo "‚úÖ Firmware tested successfully on ATS node"
        }
        failure {
            echo "‚ùå Firmware test failed"
        }
        always {
            node("${params.ATS_NODE_LABEL}") {
                dir(WORKSPACE_DIR) {
                    archiveArtifacts artifacts: "${RESULTS_DIR}/**", allowEmptyArchive: true
                }
            }
        }
    }
}
